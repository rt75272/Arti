"""Plotting and image viewing tools.

This module includes functions for plotting response curves generated by
the total knee replacement simulations.
"""

# %%
import itertools
from pathlib import Path
from typing import List, Union

import ipywidgets as widgets
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from IPython.display import display
from ipywidgets import Layout
from matplotlib.cm import ScalarMappable
from scipy import signal
from scipy.stats import median_abs_deviation
from tqdm.auto import tqdm

from artifact.constants import MODEL_DIR


# %%
def smooth(array, *, window_length=15, poly_order=3, **kwargs):
    """Smooth a 1D array using a Savitzky-Golay filter.

    Args:
        array (int|float): The array to be smoothed.
        window_length (int, optional): The length of the filter window (i.e., the
            number of coefficients). Must be a positive odd integer. Defaults to 15.
        poly_order (int, optional): Polynomial order used to fit the samples. Must
            be less than window length. Defaults to 3.

    Returns:
        int|float: The smoothed 1D array.
    """
    return signal.savgol_filter(array, window_length, poly_order, **kwargs)


def plot_response(
    x_values,
    *response_arrays,
    ylabel=None,
    legend_labels=None,
    ax=None,
    alter_linestyle: bool = True,
    **kwargs,
):
    """Plot response curves during a deep knee bend.

    Args:
        x_values ([int|float]): The independent variable array.
        *response_arrays ([float]): The response arrays.
        ylabel (str, optional): The response name for plot labeling.
            Defaults to None.
        legend_labels ([str], optional): The legend label(s) for each plotted
            response. Defaults to None.
        ax ([Axes], optional): The matplotlib axes handle to host the plot.
            Defaults to None.
    """
    if ax is None:
        ax = plt.gca()
    if legend_labels is None:
        legend_labels = [None] * len(response_arrays)
    linestyles = ["-", "--", "-.", ":"]
    linecycler = itertools.cycle(linestyles)
    for response, label in zip(response_arrays, legend_labels):
        ax.plot(
            x_values,
            smooth(response),
            label=label,
            linestyle=next(linecycler),
            **kwargs,
        )

    ax.set_xlim((x_values.min(), x_values.max()))
    ax.xaxis.set_major_formatter(mpl.ticker.PercentFormatter(xmax=x_values.max()))
    ax.set_xlabel(r"% of Knee Flexion Activity")
    ax.set_ylabel(ylabel)


def plot_bounds(x_values, training_responses, ax=None):
    """Plot population response bounds within two standard deviations.

    Args:
        x_values ([int|float]): The independent variable array.
        training_responses ([float]): A 2D array of population responses used in model
            training.
        ax (Axes, optional): The matplotlib axes handle to host the plot.
            Defaults to None.
    """
    if ax is None:
        ax = plt.gca()
    avg_response = smooth(training_responses.mean(axis=0))
    std_dev_2 = 2 * training_responses.std(axis=0)
    viridis_colormap = plt.cm.viridis(np.linspace(0, 1, 4))
    fill_color = viridis_colormap[0]
    ax.fill_between(
        x_values,
        smooth(avg_response - std_dev_2),
        smooth(avg_response + std_dev_2),
        color=fill_color,
        alpha=0.3,
        label=r"$\pm 2\sigma$",
    )


def plot_training_responses_with_bounds(
    x_values: Union[pd.Series],
    training_responses: Union[pd.DataFrame],
    num_mad: int = 2,
    scale_mad: float | str = 1.0,
    outlier_threshold: float = 0.1,
    ax: mpl.axes.Axes = None,
    plot_all_trials: bool = False,
    **smooth_kwargs,
) -> list[int]:
    """Plot every entry of a training response with bounds to detect outliers.

    Args:
        x_values (Union[np.ndarray, pd.Series]): The independent variable array.
        training_responses (Union[np.ndarray, pd.DataFrame]): A 2D array of population responses used in model
            training.
        num_mad (int, optional): Number of median absolute deviations away from the median
            to mark the cutoff for outliers. Defaults to 2.
        outlier_threshold (float, optional): The percentage of points that must be out of bounds
            to consider a response an outlier. Defaults to 0.1 (10%).
        ax (mpl.axes.Axes, optional): The matplotlib axes handle to host the plot.
            Defaults to None.

    Returns:
        List[int]: Indices of the outliers.
    """
    x_values = x_values.astype(float).values
    training_responses = training_responses.astype(float)
    if ax is None:
        ax = plt.gca()

    axis = smooth_kwargs.get("axis", 0)
    training_responses.loc[:, :] = smooth(
        training_responses.values, axis=axis, **smooth_kwargs
    )
    median_response = np.median(training_responses, axis=0)
    mad = num_mad * median_abs_deviation(training_responses, scale=scale_mad, axis=0)
    lower_bound = median_response - mad
    upper_bound = median_response + mad

    # Plot the median response
    ax.plot(x_values, median_response, label="Median Response", color="black")

    outliers = []
    for idx, response in training_responses.iterrows():
        smoothed_response = response
        out_of_bounds = (smoothed_response < lower_bound) | (
            smoothed_response > upper_bound
        )
        has_excess_outliers = (
            np.count_nonzero(out_of_bounds) / out_of_bounds.size > outlier_threshold
        )
        if plot_all_trials or has_excess_outliers:
            p = ax.plot(x_values, smoothed_response, label=f"{idx}")
        if has_excess_outliers:
            outliers.append(idx)

    ax.fill_between(
        x_values,
        lower_bound,
        upper_bound,
        color="blue",
        alpha=0.3,
        label=f"$\pm {num_mad} MAD$",
    )
    ax.set_xlim((x_values.min(), x_values.max()))
    ax.xaxis.set_major_formatter(mpl.ticker.PercentFormatter(xmax=x_values.max()))
    ax.set_xlabel(r"% of Knee Flexion Activity")
    ax.set_ylabel("Response")
    ax.legend(loc="best")

    return outliers


def create_plots(
    num_rows,
    num_cols,
    regressor,
    response_name,
    figure_directory,
    force_clobber=False,
    random_combined_plots: bool = False,
    save_subplots: bool = False,
    skip_plotting: bool = False,
):
    """Save images of gridded response subplots.

    A top figure directory is specified, but a subdirectory is created to store
    the plots.

    Args:
        num_rows (int): The number of rows in the subplot grid.
        num_cols (int): The number of columns in the subplot grid.
        regressor (Regressor): The fit and transformed regressor object
            storing prediction results.
        response_name (str): The response variable name for plotting.
        figure_directory (str|Path): The top-level figure directory.
        force_clobber (bool, optional): Flag to force deletion of previous
            images. Defaults to False.
        random_combined_plots (bool, optional): Flag to create random combined plots. Defaults to False.
        save_subplots (bool, optional): Flag to save individual subplots in vector format. Defaults to False.
    """
    figure_directory.mkdir(parents=True, exist_ok=True)
    save_directory = prepare_save_directory(figure_directory, response_name)
    relpath = figure_directory.relative_to(MODEL_DIR)
    publish_directory = MODEL_DIR.joinpath("publish", *relpath.parts[1:])
    publish_directory.mkdir(parents=True, exist_ok=True)
    publish_directory = prepare_save_directory(publish_directory, response_name)
    time_values, training_responses, test_responses, predicted_responses = prepare_data(
        regressor, response_name
    )
    if skip_plotting:
        return
    num_plots = int(num_rows * num_cols)
    num_images = np.ceil(len(predicted_responses) / num_plots)
    existing_plots = list(save_directory.glob("*.png"))
    if force_clobber or (num_images < len(existing_plots)):
        [plot.unlink() for plot in existing_plots]
    splits = np.arange(0, len(test_responses), num_plots)[1:]
    fig, axs = plt.subplots(num_rows, num_cols, figsize=(20, 30))
    split_combinations = zip(
        np.array_split(test_responses, splits),
        np.array_split(predicted_responses, splits),
    )
    progress_bar = tqdm(total=len(splits), desc=f"Plotting {response_name}")
    for idx, (test_split, pred_split) in enumerate(split_combinations):
        plot_split(
            axs,
            time_values,
            training_responses,
            test_split,
            pred_split,
            random_combined_plots,
            response_name,
            save_subplots,
            publish_directory,
            idx,
        )
        save_plot(fig, save_directory, response_name, idx)
        progress_bar.update(1)
        [ax.clear() for ax in axs.ravel()]
    progress_bar.close()
    plt.close(fig)


def save_individual_subplot(ax, publish_directory, response_name, idx, subplot_idx):
    response_str = response_name.replace("_", "-")
    subplot_path = publish_directory / f"{response_str}-{idx}-{subplot_idx}.svg"
    subplot_fig = plt.figure()
    # copy the original axis to the new figure
    subplot_ax = subplot_fig.add_subplot(111)
    subplot_fig.tight_layout()
    subplot_fig.savefig(subplot_path, format="svg", bbox_inches="tight")
    plt.close(subplot_fig)


def prepare_save_directory(figure_directory, response_name):
    response_str = response_name.replace("_", "-")
    save_directory = figure_directory / response_str
    save_directory.mkdir(exist_ok=True)
    return save_directory


def prepare_data(regressor, response_name):
    time_values = regressor.train_results.time[:, 1].astype(float)
    time_values = np.unique(time_values)
    training_responses = regressor.train_results.collect_response(response_name)
    test_responses = regressor.test_results.collect_response(response_name)
    predicted_responses = regressor.fit(response_name).predict()
    return time_values, training_responses, test_responses, predicted_responses


def plot_split(
    axs,
    time_values,
    training_responses,
    test_split,
    pred_split,
    random_combined_plots,
    response_name,
    save_subplots,
    publish_directory,
    idx,
):
    ax_progress_bar = tqdm(axs.ravel())
    labels = ["Simulated", "Predicted"]
    ylabel = response_name.replace("_", " ").title()
    if save_subplots:
        subplot_fig = plt.figure()
    for subplot_idx, (ax, test_response, pred_response) in enumerate(
        zip(ax_progress_bar, test_split, pred_split)
    ):
        if random_combined_plots:
            plot_random_combined(
                ax,
                time_values,
                training_responses,
                test_split,
                pred_split,
                labels,
                ylabel,
            )
            if save_subplots:
                subplot_ax = subplot_fig.add_subplot(111)
                plot_random_combined(
                    subplot_ax,
                    time_values,
                    training_responses,
                    test_split,
                    pred_split,
                    labels,
                    ylabel,
                )
                subplot_fig.tight_layout()
                subplot_fig.savefig(
                    publish_directory / f"{response_name}-{idx}-{subplot_idx}.svg",
                    format="svg",
                    bbox_inches="tight",
                )
                subplot_fig.clear()
        else:
            plot_bounds(time_values, training_responses, ax=ax)
            plot_response(
                time_values,
                test_response,
                pred_response,
                legend_labels=labels,
                ylabel=ylabel,
                ax=ax,
            )
            if save_subplots:
                subplot_ax = subplot_fig.add_subplot(111)
                plot_bounds(time_values, training_responses, ax=subplot_ax)
                plot_response(
                    time_values,
                    test_response,
                    pred_response,
                    legend_labels=labels,
                    ylabel=ylabel,
                    ax=ax,
                )
                subplot_fig.tight_layout()
                subplot_fig.legend(loc="best")
                subplot_fig.savefig(
                    publish_directory / f"{response_name}-{idx}-{subplot_idx}.svg",
                    format="svg",
                    bbox_inches="tight",
                )
                subplot_fig.clear()
    if save_subplots:
        plt.close(subplot_fig)
    ax_progress_bar.close()
    ax.legend(loc="best")


def plot_random_combined(
    ax, time_values, training_responses, test_split, pred_split, labels, ylabel
):
    try:
        idxs = np.random.choice(len(test_split), 4, replace=False)
    except ValueError:
        idxs = range(len(test_split))
    test_sample = test_split[idxs]
    pred_sample = pred_split[idxs]
    plot_bounds(time_values, training_responses, ax=ax)
    viridis_colormap = plt.cm.viridis(np.linspace(1, 0, len(idxs)))
    for i in range(len(idxs)):
        plot_response(
            time_values,
            test_sample[i],
            pred_sample[i],
            ax=ax,
            color=viridis_colormap[i],
            legend_labels=labels if i == len(idxs) - 1 else None,
            ylabel=ylabel if i == len(idxs) - 1 else None,
        )


def save_plot(fig, save_directory, response_name, idx):
    response_str = response_name.replace("_", "-")
    save_path = save_directory / "-".join((response_str, str(idx)))
    fig.savefig(save_path, bbox_inches="tight")


def pareto(heights, colormap=None, names=None):
    """Create a pareto chart.

    Pareto charts display the values in the vector Y as bars drawn in
    descending order. Values in Y must be nonnegative and not include NaNs.
    By default, either the tallest 10 bars or first 95% of the cumulative
    distribution is displayed, whichever is smaller.

    Args:
        heights ([int|float]): The vector to be charted.
        colormap (ColorMap, optional): The matplotlib colormap to be used in the
            chart. Defaults to None.
        names ([str], optional): An array of x-axis labels for the entries in
            the heights vector. Defaults to None.

    Returns:
        [type]: [description]
    """
    fig = plt.gcf()
    ax = fig.add_subplot(1, 1, 1)
    ax.grid(which="major", axis="y")
    ax.set_axisbelow(True)
    total_height = np.sum(heights)

    bar_ticks = range(len(heights))
    data_color = [height / max(heights) for height in heights]
    colormap = plt.cm.get_cmap()
    colors = colormap(data_color)
    if colormap is not None:
        colormap = plt.cm.get_cmap(colormap)
        colors = colormap(data_color)
        scalar_mappable = ScalarMappable(
            cmap=colormap, norm=plt.Normalize(0, max(data_color))
        )
        scalar_mappable.set_array([])
        bar = ax.bar(bar_ticks, heights, color=colors, edgecolor="k", tick_label=names)
    else:
        bar = ax.bar(bar_ticks, heights, edgecolor="k", tick_label=names)

    ax.set_xticks(bar_ticks)
    if names is not None:
        plt.xticks(rotation=45, ha="right")
    ax.set_ylim((0, total_height))
    yticks = ax.get_yticks()
    if max(yticks) < 0.9 * total_height:
        yticks = np.unique(np.append(yticks, total_height))
    ax.set_yticks(yticks)
    ylim = ax.get_ylim()

    ax2 = plt.twinx()
    line = ax2.plot(bar_ticks, np.cumsum(heights), ".-", color=colormap(0))
    ax2.set_ylim(ylim)
    ax2.spines["right"].set_color(colormap(0))
    ax2.tick_params(axis="y", colors=colormap(0))
    ax2.title.set_color(colormap(0))
    ax2.grid(False)
    fig.canvas.draw()
    yticks = ax2.get_yticks()
    yticks = np.round(yticks / total_height * 100).astype(int)
    labels = [str(yt) + "%" for yt in yticks]
    ax2.set_yticks(ax2.get_yticks().tolist())
    ax2.set_yticklabels(labels)
    return (bar, line), (ax, ax2)


class ImageViewer:
    """Interactive image viewer that recursively searches for images.

    The images should be stored in depth-two subdirectories.

    Top directory
        First regressor directory
        First response directory
            r00-img-00.png
            r00-img-01.png
            ...
        Second response directory
            r01-img-00.png
            ...
        ...
    ...


    """

    def __init__(self, top_directory) -> None:
        """Construct an ImageViewer object.

        Args:
            top_directory (str|Path): The top-level directory to recursively search
                for images.
        """
        top_directory = Path(top_directory)

        self.group_directory_list = [x for x in top_directory.iterdir() if x.is_dir()]
        self.current_group_directory = self.group_directory_list[0]
        self.group_directory_names = [x.name for x in self.group_directory_list]
        self.response_index = 0

        self.layout = Layout(
            display="flex",
            flex_flow="row",
            align_items="stretch",
            justify_content="space-between",
            width="100%",
        )

        self.viewer = widgets.Image(
            format="png",
        )

        self.previous_button = widgets.Button(
            description="",
            disabled=False,
            button_style="",
            tooltip="Previous image",
            icon="arrow-left",
        )

        self.group_dropdown = widgets.Dropdown(
            options=list(zip(self.group_directory_names, self.group_directory_list)),
            value=self.group_directory_list[0],
            description="Group:",
            disabled=False,
        )

        self.learner_dropdown = widgets.Dropdown(
            description="Regressor:", disabled=False
        )

        self.response_dropdown = widgets.Dropdown(
            description="Response:",
            disabled=False,
        )

        self.scrubber = widgets.IntSlider(
            value=0,
            min=0,
            step=1,
            description="",
            disabled=False,
            continuous_update=False,
            orientation="horizontal",
            readout=False,
            readout_format="d",
            layout=Layout(flex="1 1 0%", width="auto"),
        )

        self.next_button = widgets.Button(
            description="",
            disabled=False,
            button_style="",
            tooltip="Next image",
            icon="arrow-right",
        )

        self.selection_control_box = widgets.Box(
            children=(
                self.group_dropdown,
                self.learner_dropdown,
                self.response_dropdown,
            ),
            layout=self.layout,
        )

        self.scrub_control_box = widgets.Box(
            children=(self.previous_button, self.scrubber, self.next_button),
            layout=self.layout,
        )

        self.previous_button.on_click(self._on_previous_button_clicked)
        self.next_button.on_click(self._on_next_button_clicked)
        self.scrubber.observe(self._on_scrubber_change, names="value")

        self.group_dropdown.observe(self._on_group_dropdown_change, names="value")
        self.learner_dropdown.observe(self._on_regressor_dropdown_change, names="value")
        self.response_dropdown.observe(self._on_response_dropdown_change, names="value")
        children = [self.viewer, self.selection_control_box, self.scrub_control_box]
        self.gui = widgets.VBox(children)
        self._update_regressor_directory_list()
        self.scrubber.max = len(self.image_list) - 1

    def _render_image(self):
        image_path = self.image_list[self.scrubber.value]
        with open(str(image_path), "rb") as file:
            self.image = file.read()
        self.viewer.value = self.image

    def _update_image_list(self):
        self.image_list = list(self.current_response_directory.glob("*.png"))
        self._render_image()

    def _update_response_directory_list(self):
        self.response_directory_list = [
            x for x in self.current_learner_directory.iterdir() if x.is_dir()
        ]
        self.response_directory_names = [x.name for x in self.response_directory_list]
        self.current_response_directory = self.response_directory_list[
            self.response_index
        ]
        new_options = list(
            zip(self.response_directory_names, self.response_directory_list)
        )
        self.response_dropdown.unobserve(self._on_response_dropdown_change, "value")
        self.response_dropdown.options = new_options
        self.response_dropdown.observe(self._on_response_dropdown_change, "value")
        self.response_dropdown.value = self.current_response_directory
        self._update_image_list()

    def _update_regressor_directory_list(self):
        self.learner_directory_list = [
            x for x in self.current_group_directory.iterdir() if x.is_dir()
        ]
        self.learner_directory_names = [x.name for x in self.learner_directory_list]
        self.current_learner_directory = self.learner_directory_list[0]
        self.learner_dropdown.options = list(
            zip(self.learner_directory_names, self.learner_directory_list)
        )
        self.learner_dropdown.value = self.current_learner_directory
        self._update_response_directory_list()

    def _on_response_dropdown_change(self, change):
        self.current_response_directory = change["new"]
        self.response_index = self.response_directory_names.index(
            self.current_response_directory.name
        )
        self._update_image_list()

    def _on_regressor_dropdown_change(self, change):
        self.current_learner_directory = change["new"]
        self._update_response_directory_list()

    def _on_group_dropdown_change(self, change):
        self.response_index = 0
        self.current_group_directory = change["new"]
        self._update_regressor_directory_list()

    def _on_next_button_clicked(self, b):
        self.scrubber.value += 1

    def _on_previous_button_clicked(self, b):
        self.scrubber.value -= 1

    def _on_scrubber_change(self, change):
        self._render_image()

    def show(self):
        """Display the image viewer widget."""
        display(self.gui)

    def __call__(self):
        """Return the object for method chaining following construction.

        Returns:
            ImageViewer: The instantiated object.
        """
        return self
